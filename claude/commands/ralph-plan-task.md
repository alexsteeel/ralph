---
name: ralph-plan-task
description: Plan task (project#N) - analyze, create plan, get approval
arguments:
  - name: task_ref
    description: Task reference in format "project#N" (e.g., "myproject#18")
    required: true
---

Ты выполняешь ПЛАНИРОВАНИЕ задачи.

## STOP — НЕ РЕАЛИЗУЙ!

⛔ **ЗАПРЕЩЕНО**: писать код, создавать файлы, редактировать код, запускать тесты
✅ **РАЗРЕШЕНО**: читать код, анализировать, планировать, задавать вопросы

После записи плана в задачу — **НЕМЕДЛЕННО ОСТАНОВИСЬ**.

## Принципы

- **Только планирование** — никакой реализации, никакого кода
- **С участием человека** — уточняй все неясности
- **После планирования — ВЫХОДИ** — не начинай реализацию

## КРИТИЧНО

**План записывается В ЗАДАЧУ через md-task-mcp в поле `plan`, а НЕ в локальный файл!**

```python
# ПРАВИЛЬНО — используй поле plan:
update_task(project="...", number=N, plan="текст плана", status="work")

# НЕПРАВИЛЬНО — НЕ добавляй план в body:
# body=existing_body + plan_text  # ❌ НЕ ДЕЛАЙ ТАК
```

EnterPlanMode создаёт временный файл `.plan.md` для твоих заметок во время анализа.
Финальный план ОБЯЗАТЕЛЬНО должен быть записан в поле `plan` задачи через `update_task()`.

**После записи плана в задачу — УДАЛИ временный файл `.plan.md`!**

## Входные данные

Task reference: `$ARGUMENTS`

## Workflow

### Phase 0: Get Task

Получи задачу через md-task-mcp:

```
get_task(project="<project>", number=<N>)
```

Проверь:
- Задача существует
- Есть описание (body)

Если задачи нет → выйди с ошибкой.

### Phase 1: Analyze Task Dependencies

**Цель**: найти явные и неявные связи между задачами для выявления общих паттернов и потенциальных блокираторов.

#### Шаг 1: Получи все задачи проекта

```python
tasks(project="<project>")  # Список всех задач
```

#### Шаг 2: Анализ связей

1. **Явные связи (depends_on)**:
   - Задачи, от которых зависит текущая (блокираторы)
   - Задачи, которые зависят от текущей (будут разблокированы)
   - Проверь статусы блокираторов — если не done, предупреди

2. **Неявные связи** (семантический анализ):
   - **По модулю**: задачи с тем же `module` — могут требовать координации
   - **По целям**: задачи с похожим функционалом или затрагивающие те же области кода
   - **Потенциальные блокираторы**: задачи, которые могут создать конфликты или должны быть выполнены раньше
   - **Возможности переиспользования**: общие паттерны, утилиты, абстракции

3. **Для каждой связанной задачи прочитай body и plan** (если есть):
   ```python
   tasks(project="<project>", number=<related_task_number>)
   ```

#### Шаг 3: Сформируй рекомендации

На основе анализа определи:
- **Архитектурные паттерны** для переиспользования между задачами
- **Общие абстракции** которые стоит создать
- **Порядок выполнения** если есть неявные зависимости
- **Связи для добавления** в depends_on текущей или других задач

#### Шаг 4: Обсуди с пользователем

Если найдены значимые связи:
- Покажи найденные связи и рекомендации
- Используй AskUserQuestion для уточнения:
  - Нужно ли добавить depends_on?
  - Стоит ли планировать общие паттерны?
  - Есть ли другие известные связи?

### Phase 2: Plan Mode

**Используй ultrathink mode** для глубокого анализа.

#### Шаг 1: Войди в Plan Mode

```
EnterPlanMode
```

#### Шаг 2: Анализ

1. **Прочитай проектную документацию**:
   - CLAUDE.md — правила разработки
   - README.md — структура проекта
   - docs/*.md — архитектура

2. **Проанализируй существующий код**:
   - Используй Glob, Grep, Read для поиска паттернов
   - Найди связанные компоненты и зависимости
   - Определи точки интеграции

3. **Создай план реализации** (полный и понятный, без деталей реализации):
   - **Scope**: файлы для модификации и новые файлы
   - **Code Context**: ключевые паттерны и зависимости
   - **Implementation Steps**: что нужно сделать
   - **Testing Strategy**: где тесты и что покрыть
   - **Documentation Updates**: что обновить

   **⚠️ НЕ УКАЗЫВАЙ НОМЕРА СТРОК!**

   При batch-выполнении задач код меняется между планированием и реализацией.
   Номера строк становятся неактуальными. Вместо них используй устойчивые маркеры:
   - Имена функций/классов/методов: `в функции get_user_by_id()`
   - Паттерны кода: `после блока валидации`, `в секции импортов`
   - Структурные элементы: `в конце класса UserService`, `перед return`
   - Относительные позиции: `рядом с existing_function()`, `по аналогии с create_user()`

4. **Уточни ВСЕ неясные моменты**:
   - Используй AskUserQuestion для прояснения **всех** спорных, непонятных или неоднозначных моментов
   - Если есть несколько вариантов реализации — спроси какой предпочтительнее
   - Уточни детали если требования неполные или противоречивые
   - Обсуди сомнения в архитектуре с пользователем
   - **НЕ ЗАВЕРШАЙ планирование пока есть неясности**

5. **Оцени размер задачи**:
   - Если задача требует изменений в **более чем 5-7 файлах** или **затрагивает несколько модулей/подсистем** — предложи разбиение на подзадачи
   - Каждая подзадача должна быть **автономной** и **тестируемой отдельно**
   - Используй AskUserQuestion чтобы согласовать разбиение с пользователем
   - При согласии — создай подзадачи через `create_task()` и свяжи их через `depends_on`

#### Шаг 3: Выйди из Plan Mode

```
ExitPlanMode
```

**Жди одобрения плана от пользователя.**

### Phase 3: Save Plan to Task (ОБЯЗАТЕЛЬНО!)

**После одобрения плана ОБЯЗАТЕЛЬНО запиши его в поле `plan` задачи:**

⚠️ НЕ в локальный файл `.plan.md`, НЕ в `body` — только в поле `plan`!

```python
# Подготовь план (полный и понятный, без деталей реализации)
plan_text = """
### Related Tasks
Связанные задачи (если найдены):
- **Блокираторы**: #N — описание (статус)
- **Зависимые**: #N — будет разблокирована
- **По модулю**: #N — схожая область
- **Общие паттерны**: какие абстракции можно переиспользовать

### Scope
Файлы для модификации:
- `path/to/file1.py` — что меняем
- `path/to/file2.py` — что меняем

Новые файлы (если нужны):
- `path/to/new_file.py` — назначение

### Code Context
Ключевые паттерны проекта:
- [Какие паттерны использовать]
- [Зависимости между модулями]

### Implementation Steps
1. [Что сделать]
2. [Что сделать]
...

### Testing Strategy
- Где тесты: `path/to/tests/`
- Что покрыть тестами

### Documentation Updates
[Что обновить]
"""

# Обнови задачу — используй поле plan!
update_task(
    project="<project>",
    number=<N>,
    status="work",
    started="<YYYY-MM-DD>",
    plan=plan_text  # ← ВАЖНО: поле plan, НЕ body!
)
```

Удали временный файл:
```bash
rm .plan.md
```

### Phase 4: Report

Выведи:

```
✅ ПЛАНИРОВАНИЕ ЗАВЕРШЕНО

Задача: {project}#{number} - {title}
Статус: work

План записан в задачу и готов к реализации.

Для автономной реализации используй:
/ralph-implement-python-task {project}#{number}
```

## ⛔ STOP

**После вывода отчёта — ОСТАНОВИСЬ. НЕ ПРОДОЛЖАЙ.**

- НЕ начинай реализацию
- НЕ пиши код
- НЕ создавай файлы
- НЕ запускай тесты

Реализация выполняется ОТДЕЛЬНЫМ запуском через `/ralph-implement-python-task`.

## Checklist

- [ ] Задача получена
- [ ] **Связи проанализированы** (явные depends_on + неявные по семантике)
- [ ] **Рекомендации по связям обсуждены** с пользователем (если есть)
- [ ] Документация изучена
- [ ] Код проанализирован
- [ ] План создан
- [ ] Все неясности уточнены
- [ ] Размер задачи оценён (если большая — предложено разбиение)
- [ ] План одобрен пользователем
- [ ] План записан в поле `plan` задачи (update_task с plan=)
- [ ] Статус = work
- [ ] Временный файл .plan.md удалён
